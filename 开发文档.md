# DevNote 开发文档

## 项目概述
DevNote 是一个基于 Tauri + Vue 3 的桌面应用，专门用于记录项目开发过程中的各种信息。支持 Progress（项目进度）、Bug、Todo（待办）、Note（笔记）、Idea（灵感）五个核心模块，旨在为开发者提供一个高效、不打断开发思路的记录工具。

## 技术栈
- **前端**: Vue 3 + TypeScript + Element Plus + Vite
- **后端**: Tauri (Rust)
- **数据库**: SQLite
- **编辑器**: mavon-editor (支持Markdown)
- **样式**: 自定义CSS，VSCode风格UI

## 项目结构分析

### 当前前端架构
```
src/
├── components/
│   └── Workspace.vue    # 主工作区组件，包含所有功能模块
├── main.ts             # Vue应用入口
└── App.vue             # 根组件
```

### 需要新建的前端文件结构
```
src/
├── api/                 # 新建：API接口层
│   └── database.ts      # 新建：数据库操作API
├── components/          # 现有目录
│   ├── Workspace.vue    # 现有文件
│   ├── QuickInput.vue   # 新建：快速输入组件
│   └── EditWindow.vue   # 新建：编辑窗口组件
├── types/               # 新建：TypeScript类型定义
│   └── index.ts         # 新建：统一类型导出
├── utils/               # 新建：工具函数
│   └── helpers.ts       # 新建：辅助函数
├── views/               # 新建：视图页面
│   ├── QuickInput.vue   # 新建：快速输入页面
│   └── EditWindow.vue   # 新建：编辑窗口页面
├── assets/              # 现有目录
├── main.ts              # 现有文件
├── App.vue              # 现有文件
└── vite-env.d.ts        # 现有文件
```

### 需要新建的HTML文件
```
public/
├── quick-input.html     # 新建：快速输入窗口HTML
├── edit.html           # 新建：编辑窗口HTML
├── tauri.svg           # 现有文件
└── vite.svg            # 现有文件
```

### 当前后端架构
```
src-tauri/
├── src/
│   └── main.rs         # Tauri应用入口
├── Cargo.toml          # Rust依赖配置
└── tauri.conf.json     # Tauri配置文件
```

### 需要新建的后端文件（简化版）
```
src-tauri/
├── src/
│   └── main.rs         # 现有文件（需要更新以支持插件）
├── Cargo.toml          # 现有文件（需要更新依赖）
├── tauri.conf.json     # 现有文件（需要更新配置）
└── icons/              # 现有目录（托盘图标）
```

### 根目录需要更新的文件
```
项目根目录/
├── package.json        # 现有文件（需要添加SQL插件依赖）
├── devnote.db          # 新建：SQLite数据库文件（运行时自动创建）
└── 其他现有文件...
```

## 核心功能模块

### 1. 工作区界面 (Workspace.vue)
- **左侧工具栏**: 5个模块切换按钮
- **左侧内容区**: 显示对应模块的列表
- **主编辑区**: 支持markdown的块状编辑器
- **命令输入**: 支持快速创建内容的命令行界面

### 2. 数据模型
当前前端使用的数据结构：
```typescript
// 待办事项
interface Todo {
  title: string
  content: string
  priority: number (1-3)
  finished: boolean
  createdAt: Date
  completedAt: Date | null
  blockId: string
  ideaId?: string
  ideaContent?: string
}

// Bug
interface Bug {
  title: string
  description: string
  severity: number (1-3)
  fixed: boolean
  createdAt: Date
  completedAt?: Date
  additionalInfo?: string
}

// 灵感
interface Idea {
  title: string
  content: string
  status: 'active' | 'in-progress' | 'completed' | 'discarded'
  createdAt: Date
}

// 笔记
interface Note {
  title: string
  content: string
  createdAt: Date
  lastModified: Date
}

// 项目进度
interface Progress {
  date: Date
  content: string[]
}

// 工作区块
interface Block {
  id: string
  type: 'todo' | 'bug' | 'idea' | 'note' | 'progress'
  content: string
  priority?: number  // 仅todo使用
}
```

### 3. 命令系统
当前支持的命令：
- `/t [title] [-p priority]` - 创建待办事项
- `/b [title]` - 创建Bug记录
- `/i [title]` - 创建灵感
- `/n [title]` - 创建笔记
- `/p [title]` - 创建项目进度

## 下一阶段开发计划

### 第一阶段：数据持久化 (SQLite集成)

#### 1.1 文件创建清单

**前端新建文件：**
1. `src/api/database.ts` - 数据库操作API封装
2. `src/types/index.ts` - TypeScript类型定义
3. `src/utils/helpers.ts` - 辅助工具函数

**配置文件更新：**
1. `package.json` - 添加SQL插件依赖
2. `src-tauri/Cargo.toml` - 添加Tauri插件依赖
3. `src-tauri/tauri.conf.json` - 配置SQL插件
4. `src-tauri/src/main.rs` - 更新主程序入口

#### 1.2 需要的Tauri插件
```toml
# Cargo.toml 新增依赖
[dependencies]
tauri = { version = "1", features = ["shell-open"] }
tauri-plugin-sql = { version = "1", features = ["sqlite"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

```json
// package.json 前端依赖
{
  "dependencies": {
    "@tauri-apps/plugin-sql": "^1.0.0"
  }
}
```

#### 1.2 需要的Tauri插件
```toml
# Cargo.toml 新增依赖
[dependencies]
tauri = { version = "1", features = ["shell-open"] }
tauri-plugin-sql = { version = "1", features = ["sqlite"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

```json
// package.json 前端依赖
{
  "dependencies": {
    "@tauri-apps/plugin-sql": "^1.0.0"
  }
}
```

#### 1.3 新建类型定义文件
```typescript
// src/types/index.ts - 新建文件
export interface Todo {
  id?: number
  title: string
  content: string
  priority: number // 1-3
  finished: boolean
  createdAt: Date
  completedAt: Date | null
  blockId: string
  ideaId?: string
  ideaContent?: string
}

export interface Bug {
  id?: number
  title: string
  description: string
  severity: number // 1-3
  fixed: boolean
  createdAt: Date
  completedAt?: Date
  additionalInfo?: string
}

export interface Idea {
  id?: number
  title: string
  content: string
  status: 'active' | 'in-progress' | 'completed' | 'discarded'
  createdAt: Date
}

export interface Note {
  id?: number
  title: string
  content: string
  createdAt: Date
  lastModified: Date
}

export interface Progress {
  id?: number
  date: Date
  content: string[]
  createdAt?: Date
}

export interface Block {
  id: string
  type: 'todo' | 'bug' | 'idea' | 'note' | 'progress'
  content: string
  priority?: number
  createdAt?: Date
}
```

#### 1.4 数据库设计
```sql
-- 创建数据库表
CREATE TABLE IF NOT EXISTS todos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT DEFAULT '',
    priority INTEGER DEFAULT 2,
    finished BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    block_id TEXT,
    idea_id TEXT,
    idea_content TEXT
);

CREATE TABLE IF NOT EXISTS bugs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    description TEXT DEFAULT '',
    severity INTEGER DEFAULT 2,
    fixed BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    additional_info TEXT
);

CREATE TABLE IF NOT EXISTS ideas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT DEFAULT '',
    status TEXT DEFAULT 'active',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT DEFAULT '',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_modified DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS progresses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date DATE NOT NULL,
    content TEXT NOT NULL, -- JSON数组存储当日进度列表
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS blocks (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,
    content TEXT DEFAULT '',
    priority INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

#### 1.3 Tauri配置更新
```json
// tauri.conf.json
{
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "plugins": {
      "sql": {
        "preload": ["sqlite:devnote.db"]
      }
    }
  }
}
```

```rust
// src-tauri/src/main.rs - 极简配置
use tauri_plugin_sql;

fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_sql::Builder::default().build())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 1.5 Tauri配置更新
```json
// tauri.conf.json
{
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      }
    },
    "plugins": {
      "sql": {
        "preload": ["sqlite:devnote.db"]
      }
    }
  }
}
```

```rust
// src-tauri/src/main.rs - 极简配置
use tauri_plugin_sql;

fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_sql::Builder::default().build())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 1.6 前端直接调用SQL API
```typescript
// src/api/database.ts
import Database from '@tauri-apps/plugin-sql'

let db: Database | null = null

// 初始化数据库连接
export async function initDatabase() {
  if (!db) {
    db = await Database.load('sqlite:devnote.db')
    await createTables()
  }
  return db
}

// 创建数据表
async function createTables() {
  const database = await initDatabase()
  
  // 创建todos表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS todos (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      content TEXT DEFAULT '',
      priority INTEGER DEFAULT 2,
      finished BOOLEAN DEFAULT FALSE,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      completed_at DATETIME,
      block_id TEXT,
      idea_id TEXT,
      idea_content TEXT
    )
  `)

  // 创建bugs表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS bugs (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      description TEXT DEFAULT '',
      severity INTEGER DEFAULT 2,
      fixed BOOLEAN DEFAULT FALSE,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      completed_at DATETIME,
      additional_info TEXT
    )
  `)

  // 创建ideas表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS ideas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      content TEXT DEFAULT '',
      status TEXT DEFAULT 'active',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `)

  // 创建notes表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS notes (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      content TEXT DEFAULT '',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      last_modified DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `)

  // 创建progresses表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS progresses (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      date DATE NOT NULL UNIQUE,
      content TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `)

  // 创建blocks表
  await database.execute(`
    CREATE TABLE IF NOT EXISTS blocks (
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      content TEXT DEFAULT '',
      priority INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `)
}

// Database API类 - 直接调用SQL
export class DatabaseAPI {
  // Todo相关操作
  static async getTodos(): Promise<Todo[]> {
    const database = await initDatabase()
    return await database.select('SELECT * FROM todos ORDER BY created_at DESC')
  }
  
  static async createTodo(todo: Partial<Todo>): Promise<number> {
    const database = await initDatabase()
    const result = await database.execute(
      'INSERT INTO todos (title, content, priority, finished, block_id, idea_id, idea_content) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [todo.title, todo.content || '', todo.priority || 2, todo.finished || false, todo.blockId, todo.ideaId, todo.ideaContent]
    )
    return result.lastInsertId
  }
  
  static async updateTodo(id: number, todo: Partial<Todo>): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'UPDATE todos SET title = ?, content = ?, priority = ?, finished = ?, completed_at = ? WHERE id = ?',
      [todo.title, todo.content, todo.priority, todo.finished, todo.completedAt, id]
    )
  }
  
  static async deleteTodo(id: number): Promise<void> {
    const database = await initDatabase()
    await database.execute('DELETE FROM todos WHERE id = ?', [id])
  }

  // Bug相关操作
  static async getBugs(): Promise<Bug[]> {
    const database = await initDatabase()
    return await database.select('SELECT * FROM bugs ORDER BY created_at DESC')
  }
  
  static async createBug(bug: Partial<Bug>): Promise<number> {
    const database = await initDatabase()
    const result = await database.execute(
      'INSERT INTO bugs (title, description, severity, fixed, additional_info) VALUES (?, ?, ?, ?, ?)',
      [bug.title, bug.description || '', bug.severity || 2, bug.fixed || false, bug.additionalInfo]
    )
    return result.lastInsertId
  }
  
  static async updateBug(id: number, bug: Partial<Bug>): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'UPDATE bugs SET title = ?, description = ?, severity = ?, fixed = ?, completed_at = ?, additional_info = ? WHERE id = ?',
      [bug.title, bug.description, bug.severity, bug.fixed, bug.completedAt, bug.additionalInfo, id]
    )
  }

  // Idea相关操作
  static async getIdeas(): Promise<Idea[]> {
    const database = await initDatabase()
    return await database.select('SELECT * FROM ideas ORDER BY created_at DESC')
  }
  
  static async createIdea(idea: Partial<Idea>): Promise<number> {
    const database = await initDatabase()
    const result = await database.execute(
      'INSERT INTO ideas (title, content, status) VALUES (?, ?, ?)',
      [idea.title, idea.content || '', idea.status || 'active']
    )
    return result.lastInsertId
  }
  
  static async updateIdea(id: number, idea: Partial<Idea>): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'UPDATE ideas SET title = ?, content = ?, status = ? WHERE id = ?',
      [idea.title, idea.content, idea.status, id]
    )
  }

  // Note相关操作
  static async getNotes(): Promise<Note[]> {
    const database = await initDatabase()
    return await database.select('SELECT * FROM notes ORDER BY last_modified DESC')
  }
  
  static async createNote(note: Partial<Note>): Promise<number> {
    const database = await initDatabase()
    const result = await database.execute(
      'INSERT INTO notes (title, content) VALUES (?, ?)',
      [note.title, note.content || '']
    )
    return result.lastInsertId
  }
  
  static async updateNote(id: number, note: Partial<Note>): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'UPDATE notes SET title = ?, content = ?, last_modified = CURRENT_TIMESTAMP WHERE id = ?',
      [note.title, note.content, id]
    )
  }

  // Progress相关操作
  static async getProgresses(): Promise<Progress[]> {
    const database = await initDatabase()
    const rows = await database.select('SELECT * FROM progresses ORDER BY date DESC')
    return rows.map(row => ({
      ...row,
      content: JSON.parse(row.content)
    }))
  }
  
  static async createOrUpdateProgress(date: string, content: string[]): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'INSERT OR REPLACE INTO progresses (date, content) VALUES (?, ?)',
      [date, JSON.stringify(content)]
    )
  }

  // Block相关操作
  static async getBlocks(): Promise<Block[]> {
    const database = await initDatabase()
    return await database.select('SELECT * FROM blocks ORDER BY created_at DESC')
  }
  
  static async createBlock(block: Block): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'INSERT INTO blocks (id, type, content, priority) VALUES (?, ?, ?, ?)',
      [block.id, block.type, block.content, block.priority]
    )
  }
  
  static async updateBlock(id: string, content: string): Promise<void> {
    const database = await initDatabase()
    await database.execute(
      'UPDATE blocks SET content = ? WHERE id = ?',
      [content, id]
    )
  }
  
  static async deleteBlock(id: string): Promise<void> {
    const database = await initDatabase()
    await database.execute('DELETE FROM blocks WHERE id = ?', [id])
  }
}
```

#### 1.7 在组件中使用数据库API
```vue
<!-- 在 Workspace.vue 中集成数据库 -->
<script setup lang="ts">
import { onMounted } from 'vue'
import { DatabaseAPI } from '../api/database'

// 在组件挂载时初始化数据库并加载数据
onMounted(async () => {
  try {
    // 初始化数据库
    await DatabaseAPI.initDatabase()
    
    // 加载所有数据
    await loadAllData()
    
    // 其他初始化...
  } catch (error) {
    console.error('数据库初始化失败:', error)
  }
})

// 加载所有数据
const loadAllData = async () => {
  const [todosData, bugsData, ideasData, notesData, progressesData] = await Promise.all([
    DatabaseAPI.getTodos(),
    DatabaseAPI.getBugs(), 
    DatabaseAPI.getIdeas(),
    DatabaseAPI.getNotes(),
    DatabaseAPI.getProgresses()
  ])
  
  // 更新响应式数据
  todos.splice(0, todos.length, ...todosData)
  bugs.splice(0, bugs.length, ...bugsData)
  ideas.splice(0, ideas.length, ...ideasData)
  notes.splice(0, notes.length, ...notesData)
  progresses.splice(0, progresses.length, ...progressesData)
}

// 修改现有的createBlock函数，同时保存到数据库
const createBlock = async (type: string, title = '', priority = 2) => {
  // 创建block对象
  const newBlock = {
    id: generateId(),
    type: type,
    content: title ? (type === 'todo' ? `**${title}**` : `# ${title}`) : ''
  }
  
  if (type === 'todo') {
    newBlock.priority = priority
  }
  
  // 保存到内存
  blocks.push(newBlock)
  
  // 保存到数据库
  await DatabaseAPI.createBlock(newBlock)
  
  // 其余逻辑保持不变...
}

// 修改现有的updateTodayProgress函数，同时保存到数据库
const updateTodayProgress = async () => {
  // 现有逻辑...
  
  // 如果有今日进度，保存到数据库
  if (todayProgress.value) {
    const dateStr = todayProgress.value.date.toISOString().split('T')[0]
    await DatabaseAPI.createOrUpdateProgress(dateStr, todayProgress.value.content)
  }
}
</script>
```

### 第二阶段：全局快捷键和托盘功能

#### 2.1 文件创建清单

**新建页面文件：**
1. `public/quick-input.html` - 快速输入窗口HTML页面
2. `src/views/QuickInput.vue` - 快速输入组件
3. `src/components/QuickInput.vue` - 复用的快速输入组件

**配置文件更新：**
1. `src-tauri/Cargo.toml` - 添加快捷键和托盘插件
2. `src-tauri/tauri.conf.json` - 配置快捷键和托盘
3. `src-tauri/src/main.rs` - 添加快捷键和托盘处理逻辑

#### 数据库方案优势对比

**✅ 直接使用SQL插件的优势：**
- **更简单**: 不需要编写Rust代码，纯前端操作
- **更灵活**: 可以直接写复杂的SQL查询，支持事务
- **更快速**: 减少了Rust函数调用的开销
- **更易调试**: 可以直接在浏览器调试SQL语句
- **类型安全**: TypeScript提供完整的类型检查

**❌ vs 封装Rust命令的方式：**
- 需要为每个操作写Rust函数
- 前后端类型需要同步维护
- 调试更复杂，需要在Rust端打日志
- 开发效率较低

#### 2.2 需要的Tauri插件
```toml
# Cargo.toml 新增依赖
tauri-plugin-global-shortcut = "1"
tauri-plugin-system-tray = "1"
tauri-plugin-window = "1"
```

#### 2.3 新建HTML文件
```html
<!-- public/quick-input.html - 新建文件 -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>快速输入</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module" src="/src/views/QuickInput.vue"></script>
</body>
</html>
```

#### 2.4 托盘功能实现
```rust
// src-tauri/src/main.rs
use tauri::{SystemTray, SystemTrayMenu, SystemTrayEvent, CustomMenuItem};

fn create_system_tray() -> SystemTray {
    let quit = CustomMenuItem::new("quit".to_string(), "退出");
    let show = CustomMenuItem::new("show".to_string(), "显示主窗口");
    let quick_input = CustomMenuItem::new("quick_input".to_string(), "快速输入");
    
    let tray_menu = SystemTrayMenu::new()
        .add_item(show)
        .add_item(quick_input)
        .add_native_item(tauri::SystemTrayMenuItem::Separator)
        .add_item(quit);
    
    SystemTray::new().with_menu(tray_menu)
}

fn handle_system_tray_event(app: &tauri::AppHandle, event: SystemTrayEvent) {
    match event {
        SystemTrayEvent::MenuItemClick { id, .. } => {
            match id.as_str() {
                "quit" => {
                    std::process::exit(0);
                }
                "show" => {
                    let window = app.get_window("main").unwrap();
                    window.show().unwrap();
                    window.set_focus().unwrap();
                }
                "quick_input" => {
                    create_quick_input_window(app);
                }
                _ => {}
            }
        }
        _ => {}
    }
}
```

#### 2.5 全局快捷键实现
```rust
use tauri_plugin_global_shortcut::{GlobalShortcutExt, Shortcut};

fn setup_global_shortcut(app: &tauri::App) -> Result<(), Box<dyn std::error::Error>> {
    let app_handle = app.handle();
    
    // 注册 Ctrl+Shift+D 快捷键
    app.global_shortcut().register("CmdOrCtrl+Shift+D", move || {
        create_quick_input_window(&app_handle);
    })?;
    
    Ok(())
}

fn create_quick_input_window(app: &tauri::AppHandle) {
    let window = tauri::WindowBuilder::new(
        app,
        "quick_input",
        tauri::WindowUrl::App("quick-input.html".into())
    )
    .title("快速输入")
    .inner_size(400.0, 150.0)
    .resizable(false)
    .always_on_top(true)
    .center()
    .decorations(false)
    .skip_taskbar(true)
    .build();
    
    if let Ok(window) = window {
        window.show().unwrap();
        window.set_focus().unwrap();
    }
}
```

#### 2.6 快速输入窗口
创建独立的快速输入组件：
```vue
<!-- src/views/QuickInput.vue -->
<template>
  <div class="quick-input-container" @keydown.esc="closeWindow">
    <input 
      ref="inputRef"
      v-model="command"
      class="quick-input"
      placeholder="输入命令 (例如: /t 修复登录bug -p 1)"
      @keydown.enter="handleSubmit"
      @blur="handleBlur"
    />
    <div class="command-hint">
      /t=待办 /b=Bug /i=灵感 /n=笔记 /p=进度
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { appWindow } from '@tauri-apps/api/window'
import { invoke } from '@tauri-apps/api/tauri'

const inputRef = ref<HTMLInputElement>()
const command = ref('')

onMounted(() => {
  // 自动聚焦
  inputRef.value?.focus()
})

const handleSubmit = async () => {
  if (command.value.trim()) {
    // 解析命令并创建对应的记录
    await parseAndExecuteCommand(command.value.trim())
    
    // 创建编辑窗口
    await createEditWindow()
  }
  closeWindow()
}

const handleBlur = () => {
  // 失去焦点时关闭窗口
  setTimeout(() => {
    closeWindow()
  }, 100)
}

const closeWindow = () => {
  appWindow.close()
}

const parseAndExecuteCommand = async (cmd: string) => {
  // 实现命令解析逻辑
  const parts = cmd.split(' ')
  const type = parts[0]
  const title = parts.slice(1).join(' ')
  
  const typeMap = {
    '/t': 'todo',
    '/b': 'bug', 
    '/i': 'idea',
    '/n': 'note',
    '/p': 'progress'
  }
  
  if (typeMap[type]) {
    await invoke('create_quick_record', {
      type: typeMap[type],
      title: title
    })
  }
}

const createEditWindow = async () => {
  await invoke('create_edit_window')
}
</script>
```

### 第三阶段：浮动编辑窗口

#### 3.1 文件创建清单

**新建页面文件：**
1. `public/edit.html` - 编辑窗口HTML页面  
2. `src/views/EditWindow.vue` - 编辑窗口组件
3. `src/components/EditWindow.vue` - 复用的编辑组件

**工具函数：**
1. `src/utils/window-manager.ts` - 窗口管理工具
2. `src/utils/record-utils.ts` - 记录操作工具函数

#### 3.2 编辑窗口实现
```rust
#[command]
async fn create_edit_window(app: tauri::AppHandle, record_type: String, record_id: i64) {
    let window = tauri::WindowBuilder::new(
        &app,
        &format!("edit_{}", record_id),
        tauri::WindowUrl::App(format!("edit.html?type={}&id={}", record_type, record_id).into())
    )
    .title("编辑记录")
    .inner_size(500.0, 400.0)
    .resizable(true)
    .always_on_top(true)
    .decorations(true)
    .skip_taskbar(false)
    .build();
    
    if let Ok(window) = window {
        window.show().unwrap();
        window.set_focus().unwrap();
    }
}
```

#### 3.3 编辑组件
```vue
<!-- src/views/EditWindow.vue -->
<template>
  <div class="edit-window" @focusout="handleFocusOut">
    <div class="edit-header">
      <input 
        v-model="record.title" 
        class="title-input"
        placeholder="标题"
      />
      <div class="edit-actions">
        <button @click="saveRecord" class="save-btn">保存</button>
        <button @click="closeWindow" class="close-btn">关闭</button>
      </div>
    </div>
    
    <div class="edit-content">
      <mavon-editor
        v-model="record.content"
        :toolbars="editorConfig"
        @save="saveRecord"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { appWindow } from '@tauri-apps/api/window'
import { DatabaseAPI } from '../api/database'

const record = ref({
  title: '',
  content: '',
  type: '',
  id: null
})

onMounted(async () => {
  // 从URL参数获取记录信息
  const urlParams = new URLSearchParams(window.location.search)
  const type = urlParams.get('type')
  const id = urlParams.get('id')
  
  if (type && id) {
    // 加载记录数据
    await loadRecord(type, parseInt(id))
  }
})

const loadRecord = async (type: string, id: number) => {
  // 根据类型调用对应的API
  switch (type) {
    case 'todo':
      record.value = await DatabaseAPI.getTodo(id)
      break
    case 'bug':
      record.value = await DatabaseAPI.getBug(id)
      break
    // 其他类型...
  }
}

const saveRecord = async () => {
  // 保存记录
  await DatabaseAPI.updateRecord(record.value)
}

const handleFocusOut = () => {
  // 检查是否完全失去焦点
  setTimeout(() => {
    if (!document.hasFocus()) {
      closeWindow()
    }
  }, 100)
}

const closeWindow = () => {
  appWindow.close()
}
</script>
```

#### 3.4 新建HTML文件
```html
<!-- public/edit.html - 新建文件 -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>编辑记录</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module" src="/src/views/EditWindow.vue"></script>
</body>
</html>
```

#### 3.5 窗口管理工具
```typescript
// src/utils/window-manager.ts - 新建文件
import { invoke } from '@tauri-apps/api/tauri'
import { appWindow } from '@tauri-apps/api/window'

export class WindowManager {
  static async createQuickInputWindow() {
    return await invoke('create_quick_input_window')
  }
  
  static async createEditWindow(recordType: string, recordId: number) {
    return await invoke('create_edit_window', {
      recordType,
      recordId
    })
  }
  
  static async closeCurrentWindow() {
    return await appWindow.close()
  }
  
  static async focusMainWindow() {
    return await invoke('focus_main_window')
  }
}
```

### 第四阶段：配置和优化

#### 4.1 文件创建清单

**配置文件：**
1. `src/config/app.config.ts` - 应用配置文件
2. `src/config/database.config.ts` - 数据库配置

**样式文件：**
1. `src/styles/global.css` - 全局样式
2. `src/styles/themes.css` - 主题样式

**测试文件：**
1. `tests/database.test.ts` - 数据库测试
2. `tests/components.test.ts` - 组件测试

#### 4.2 配置文件更新
```json
// tauri.conf.json
{
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "globalShortcut": {
        "all": true
      },
      "systemTray": {
        "all": true
      },
      "window": {
        "all": false,
        "create": true,
        "center": true,
        "requestUserAttention": true,
        "setResizable": true,
        "setTitle": true,
        "maximize": true,
        "unmaximize": true,
        "minimize": true,
        "unminimize": true,
        "show": true,
        "hide": true,
        "close": true,
        "setDecorations": true,
        "setAlwaysOnTop": true,
        "setSize": true,
        "setMinSize": true,
        "setMaxSize": true,
        "setPosition": true,
        "setFullscreen": true,
        "setFocus": true,
        "setIcon": true,
        "setSkipTaskbar": true,
        "setCursorGrab": true,
        "setCursorVisible": true,
        "setCursorIcon": true,
        "setCursorPosition": true,
        "setIgnoreCursorEvents": true,
        "startDragging": true,
        "print": true
      }
    },
    "systemTray": {
      "iconPath": "icons/icon.png",
      "iconAsTemplate": true
    }
  }
}
```

#### 4.3 新建配置文件
```typescript
// src/config/app.config.ts - 新建文件
export const AppConfig = {
  // 窗口配置
  windows: {
    main: {
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600
    },
    quickInput: {
      width: 400,
      height: 150
    },
    edit: {
      width: 500,
      height: 400,
      minWidth: 400,
      minHeight: 300
    }
  },
  
  // 快捷键配置
  shortcuts: {
    quickInput: 'CmdOrCtrl+Shift+D',
    toggleWindow: 'CmdOrCtrl+Shift+W'
  },
  
  // 编辑器配置
  editor: {
    toolbar: {
      bold: true,
      italic: true,
      header: true,
      strikethrough: true,
      mark: true,
      superscript: true,
      subscript: true,
      quote: true,
      ol: true,
      ul: true,
      link: true,
      imagelink: true,
      code: true,
      table: true,
      fullscreen: true,
      readmodel: true,
      htmlcode: true,
      help: true,
      undo: true,
      redo: true,
      trash: true,
      save: true,
      navigation: true,
      alignleft: true,
      aligncenter: true,
      alignright: true,
      subfield: true,
      preview: true
    }
  }
}
```

```typescript
// src/config/database.config.ts - 新建文件
export const DatabaseConfig = {
  name: 'devnote.db',
  version: '1.0.0',
  tables: {
    todos: 'todos',
    bugs: 'bugs', 
    ideas: 'ideas',
    notes: 'notes',
    progresses: 'progresses',
    blocks: 'blocks'
  },
  migrations: [
    // 版本升级SQL脚本
  ]
}
```

#### 4.4 性能优化建议

1. **数据库优化**：
   - 为经常查询的字段添加索引
   - 实现分页加载大量数据
   - 使用连接池管理数据库连接

2. **内存优化**：
   - 实现虚拟滚动处理大列表
   - 及时清理不再使用的窗口实例
   - 使用 `shallowRef` 优化大对象

3. **用户体验优化**：
   - 添加加载状态提示
   - 实现离线数据缓存
   - 添加数据备份和恢复功能

## 完整文件创建清单

### 第一阶段需要创建的文件
```
src/
├── api/
│   └── database.ts              # 新建：数据库操作API
├── types/
│   └── index.ts                 # 新建：TypeScript类型定义
└── utils/
    └── helpers.ts               # 新建：辅助工具函数

更新文件：
- package.json                   # 添加 @tauri-apps/plugin-sql
- src-tauri/Cargo.toml          # 添加 tauri-plugin-sql
- src-tauri/tauri.conf.json     # 配置SQL插件
- src-tauri/src/main.rs         # 添加SQL插件
- src/components/Workspace.vue   # 集成数据库API
```

### 第二阶段需要创建的文件
```
public/
└── quick-input.html             # 新建：快速输入窗口HTML

src/
├── views/
│   └── QuickInput.vue           # 新建：快速输入页面组件
└── components/
    └── QuickInput.vue           # 新建：复用快速输入组件

更新文件：
- src-tauri/Cargo.toml          # 添加快捷键和托盘插件
- src-tauri/tauri.conf.json     # 配置快捷键和托盘
- src-tauri/src/main.rs         # 添加快捷键和托盘逻辑
```

### 第三阶段需要创建的文件
```
public/
└── edit.html                    # 新建：编辑窗口HTML

src/
├── views/
│   └── EditWindow.vue           # 新建：编辑窗口页面组件
├── components/
│   └── EditWindow.vue           # 新建：复用编辑组件
└── utils/
    ├── window-manager.ts        # 新建：窗口管理工具
    └── record-utils.ts          # 新建：记录操作工具
```

### 第四阶段需要创建的文件
```
src/
├── config/
│   ├── app.config.ts            # 新建：应用配置
│   └── database.config.ts       # 新建：数据库配置
├── styles/
│   ├── global.css               # 新建：全局样式
│   └── themes.css               # 新建：主题样式
└── tests/
    ├── database.test.ts         # 新建：数据库测试
    └── components.test.ts       # 新建：组件测试
```

### 运行时自动生成的文件
```
项目根目录/
└── devnote.db                   # 自动生成：SQLite数据库文件
```

## 开发优先级

### 高优先级
1. **SQLite数据持久化** - 核心功能基础
2. **全局快捷键** - 核心用户体验
3. **托盘功能** - 后台运行支持

### 中优先级
1. **浮动编辑窗口** - 增强用户体验
2. **数据导入导出** - 数据安全
3. **主题定制** - 个性化

### 低优先级
1. **插件系统** - 扩展性
2. **云同步** - 跨设备支持
3. **团队协作** - 多用户功能

## 推荐的开发工具

1. **Tauri官方CLI** - 项目构建和开发
2. **SQLite Browser** - 数据库管理和调试
3. **Rust Analyzer** - Rust代码开发
4. **Vue DevTools** - Vue组件调试
5. **Postman** - API测试（如果需要）

## 总结

这个项目的核心价值在于**不打断开发思路的实时记录**。通过全局快捷键和浮动窗口的组合，开发者可以在编码过程中快速记录想法、Bug和进度，而无需切换到其他应用。

数据持久化确保了信息的安全性，而简洁的UI设计保证了操作的高效性。随着功能的逐步完善，这将成为一个强大的开发辅助工具。

建议按照上述优先级逐步实现功能，每个阶段都要确保核心功能的稳定性，然后再添加新特性。